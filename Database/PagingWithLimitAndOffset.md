# LIMIT과 OFFSET으로 페이징 처리하기 (feat. 커서 기반 페이징)

전체 목록 조회(`findAll()`) 기능을 구현할 때, 대부분 WHERE 절이 없는 `SELECT` 문을 사용했다. 만약 데이터가 10억 건이라면, 사용 가능한 메모리를 초과하지 않을까?

이처럼 한 번에 모든 데이터를 가져오는 것은 비효율적이거나 불가능할 수 있다.
따라서, 대량의 데이터를 효율적으로 처리하기 위해 페이징(Paging) 처리를 사용한다.

우리가 생각하는 게시판, 인스타 무한 스크롤 등은 모두 페이징 처리의 일종이다.

- [페이징이란?](#페이징paging이란)
- [LIMIT과 OFFSET을 활용한 페이징](#limit과-offset을-활용한-페이징)
  - [OFFSET의 동작 방식](#offset의-동작-방식)
  - [OFFSET 방식의 내부 처리 동작](#offset-방식의-내부-처리-동작)
    - [인덱스가 없는 경우](#인덱스가-없는-경우)
    - [인덱스가 있는 경우](#인덱스가-있는-경우)
- [커서 기반 페이징 (Keyset Pagination)](#커서-기반-페이징-keyset-pagination)
  - [커서 기반 페이징의 내부 처리 동작](#커서-기반-페이징의-내부-처리-동작)
    - [인덱스가 있는 경우](#인덱스가-있는-경우)
    - [인덱스가 없는 경우](#인덱스가-없는-경우)
  - [그러면 커서 기반 페이징은 무조건 좋을까?](#그러면-커서-기반-페이징은-무조건-좋을까)
- [마무리](#마무리)

## 페이징(Paging)이란?

페이징 처리는 대량의 데이터를 일정한 크기로 나누어 페이지 단위로 처리하는 방법이다.

예를 들어, 1000건의 데이터를 100건씩 나누면 10페이지로 나눌 수 있다.
사용자는 한 번에 100건씩 데이터를 조회할 수 있으며, 페이지를 이동하면서 필요한 데이터만 가져올 수 있다.

> ### Q. 운영체제의 페이징과 같은 개념인가요?
>
> 유사하다. 둘 다 전체를 나눠서 일부만 사용하자는 관점을 공유한다.
> 다만 SQL의 페이징은 주로 UX와 성능 개선을 위한 데이터 처리 방식,
> 운영체제의 페이징은 메모리 부족을 해결하기 위한 시스템 설계 기법이다.

## LIMIT과 OFFSET을 활용한 페이징

SQL에서 가장 흔히 사용하는 페이징 방법은 LIMIT과 OFFSET을 조합하는 것이다.

```sql
-- 예시: users 테이블에서 20번째부터 10개 행을 가져오기
SELECT name, age
FROM users
LIMIT 10 OFFSET 20;
```

- `LIMIT`: 최대 반환할 행 수
- `OFFSET`: 건너뛸 행 수

### OFFSET의 동작 방식

`OFFSET`을 보면 단순히 건너뛴다고 느껴진다.
그러나 내부적으로는 지정된 수만큼의 행을 읽고 버리는 것이다.

```sql
SELECT name, age
FROM users
LIMIT 10 OFFSET 10000;
```

실제로는 10,010개의 행을 읽고 그중 앞의 10,000개를 버리고, 뒤의 10개만 결과로 반환한다.
만약 정렬(`ORDER BY`)까지 포함되면 더욱 무거워진다.

결국 `OFFSET`은 값이 커질수록 성능이 선형적으로 저하된다는 것이다.
메모리 사용량 증가와 디스크 정렬 비용이 증가하기 때문이다.

### OFFSET 방식의 내부 처리 동작

**인덱스가 없는 경우**

1. 전체 테이블을 스캔한다. `Full Table Scan`
2. `ORDER BY`에 따라 모든 데이터를 정렬한다.
3. 정렬된 결과에서 `OFFSET` 수만큼 건너뛴 후 `LIMIT` 수만큼 결과를 반환한다.

데이터가 많을 경우 매우 비효율적이다.

예를 들어, 1,000,000건의 데이터를 정렬하고 그 중 990,000번째부터 10개만 가져오는 것은 엄청난 메모리 낭비를 초래한다.

**인덱스가 있는 경우**

1. 인덱스를 통해 정렬된 순서로 데이터에 접근한다.
2. 그러나 여전히 `OFFSET` 수만큼 인덱스 항목을 순차적으로 스캔한다.
3. `OFFSET + LIMIT` 위치에 도달한 후 `LIMIT` 수만큼만 실제 데이터를 가져온다.

인덱스가 있더라도 OFFSET 값이 크면 많은 인덱스 스캔이 필요하므로 여전히 데이터 양이 많아질수록 선형적으로 성능이 저하된다.

## 커서 기반 페이징 (Keyset Pagination)

`OFFSET` 방식의 성능 문제를 해결하기 위해 사용하는 방식이 커서 기반 페이징이다.
`어디까지 봤는지 기억하고 그 이후를 가져오는` 접근 방식이다.

```sql
-- 예시: age가 30 초과인 데이터부터 10개 가져오기
SELECT name, age
FROM users
WHERE age > 30
ORDER BY age
LIMIT 10;
```

이처럼 커서 조건(`WHERE age > 30`)을 활용하면, 정렬과 범위가 명확해져 불필요한 데이터 접근을 방지하고 성능을 획기적으로 개선할 수 있다.

특히 커서로 사용하는 컬럼(age)에 인덱스가 존재하면, 데이터베이스는 범위 검색을 빠르게 수행할 수 있다.
앞서 `OFFSET`으로 모든 행을 읽고 일부만 버리는 방식과는 근본적으로 다르다.

### 커서 기반 페이징의 내부 처리 동작

**인덱스가 있는 경우**

1. `WHERE` 조건과 인덱스를 활용하여 특정 값보다 크거나 작은 레코드만 필터링한다.
2. 이미 정렬된 인덱스를 통해 필요한 레코드에 직접 접근한다.
3. `LIMIT` 수만큼만 데이터를 가져온다.

`OFFSET` 방식과 비교하면 매우 효율적이며, 페이지가 깊어져도 성능 저하가 적은 편이다.

**인덱스가 없는 경우**

1. `WHERE` 조건으로 필터링된 데이터만 정렬 대상으로 사용한다.
2. `OFFSET` 방식처럼 이미 처리한 행을 건너뛰지 않고, 필터링 후 상위 N개만 처리한다.

이렇게 하면 정렬 대상 데이터의 양을 크게 줄일 수 있어 인덱스가 없어도 `OFFSET` 방식보다 효율적이다.

또한, 여러 컬럼으로 정렬(복합 인덱스)하는 경우에도 커서 기반 페이징은 유용하다고 한다.

```sql
-- 예시: 복합 인덱스 사용
SELECT name, age
FROM users
WHERE age > 30 AND name > 'John' -- 복합 커서 기준
ORDER BY age, name
LIMIT 10;
```

### 그러면 커서 기반 페이징은 무조건 좋을까?

아니다. 커서 기반 페이징은 단순히 `LIMIT`과 `OFFSET`을 대체하는 것이 아니다.

- 임의 페이지 이동이 어렵다.
  - 사용자가 `5 페이지`로 바로 가기를 원하는 경우, 커서 기반 페이징은 적합하지 않다. 이전 커서를 기준으로 다음 페이지를 순차적으로 탐색해야 하므로, 정확한 위치 접근이 어렵다.
- 커서 기반 페이징은 정렬 기준이 명확해야 한다.
  - 예를 들어, `WHERE` 조건이 `age > 30`이라면, `ORDER BY` 절도 반드시 `age`로 정렬해야 한다. 만약 `name`으로 정렬하면, 커서 기반 페이징의 의미가 퇴색된다.
- 커서 값의 전달과 보안 문제
  - 단순히 `id = 100`처럼 전달하면, 민감한 내부 ID가 외부로 노출될 수 있다.
    그래서 실무에서는 커서 값을 암호화하거나, 해시값으로 변환하여 전달하는 방법을 사용한다고 한다.

## 마무리

| 구분      | LIMIT/OFFSET                    | 커서 기반 페이징                                 |
| --------- | ------------------------------- | ------------------------------------------------ |
| 장점      | 간단하고 직관적                 | 성능이 우수하고 메모리 사용량이 적음             |
| 단점      | 성능 저하, 메모리 사용량 증가   | 임의 페이지 이동이 어려움, 정렬 기준 명확해야 함 |
| 사용 예시 | 관리자 페이지, 검색 결과 페이지 | 무한 스크롤, 최신순 정렬, 성능 우선              |

전체 목록 조회 기능을 구현할 때, 항상 데이터가 적었기에 큰 문제가 없었다.
하지만 데이터가 많아질수록 분명하게 성능 저하가 발생할 것이다. 적용해볼 수 있는 좋은 공부를 한 것 같다.

## 함께 보면 좋은 글

[Faster Pagination in Mysql – Why Order By With Limit and Offset is Slow? - EverSQL: Tomer Shay](https://www.eversql.com/faster-pagination-in-mysql-why-order-by-with-limit-and-offset-is-slow/)  
[커서 기반 페이지네이션 (Cursor-based Pagination) 구현하기 - Velog: 김민상](https://velog.io/@minsangk/%EC%BB%A4%EC%84%9C-%EA%B8%B0%EB%B0%98-%ED%8E%98%EC%9D%B4%EC%A7%80%EB%84%A4%EC%9D%B4%EC%85%98-Cursor-based-Pagination-%EA%B5%AC%ED%98%84%ED%95%98%EA%B8%B0)
