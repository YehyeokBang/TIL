# 데이터베이스에서 지우기 DELETE, TRUNCATE, DROP

우리는 보고 싶지 않은 사진을 지우듯, 데이터베이스에서도 더 이상 필요 없는 데이터를 지운다.
테스트 데이터를 초기화하거나, 오래된 로그를 제거하거나, 아예 테이블 자체를 제거할 때도 있다.

하지만 지운다는 행위는 단순하지 않다.
무엇을 지우느냐, 어떻게 지우느냐에 따라 속도와 안정성, 복구 가능 여부까지 달라진다고 한다.

데이터베이스에서 데이터를 지우는 세 가지 주요 명령어, `DELETE`, `TRUNCATE`, `DROP`의 차이점과 실제 활용 시 고려할 점을 학습하려고 한다.

## DELETE - 조건에 따라 조심히 삭제하기

`DELETE`는 테이블에서 특정 조건을 만족하는 행(row)만 선택적으로 삭제할 수 있는 명령어다.
필요한 데이터만 정밀하게 제거할 수 있지만, 그만큼 속도나 자원 측면에서 주의가 필요하다.

```sql
DELETE FROM 테이블명
WHERE 조건;

-- 예시: 2020년 이전 획득한 포인트 데이터 삭제
DELETE FROM points
WHERE create_date < '2020-01-01';
```

- `WHERE` 절을 사용하면 원하는 행만 삭제할 수 있다.
  - `WHERE`를 생략하면 모든 행이 삭제되니, 실수에 주의해야 한다.
- `DELETE`는 트랜잭션에 포함되기 때문에, 실행 후 문제가 생기면 `ROLLBACK`으로 복구할 수 있다.
  - 삭제된 데이터는 UNDO 영역에 기록되므로, 복구는 가능하지만 그만큼 성능과 저장 공간에 영향을 줄 수 있다.
- 삭제는 한 행씩 처리되므로, 데이터 양이 많을수록 속도가 느려지고 DB 부하가 커진다.
  - 대량 삭제 시에는 `LIMIT`을 함께 사용해 여러 번에 나눠서 처리하는 것이 좋다.
    ```sql
    -- 예시: 오래된 포인트 데이터 1000건씩 순차 삭제
    DELETE FROM points
    WHERE create_date < '2020-01-01'
    LIMIT 1000;
    ```
  - 또는, 배치 처리로 시간 간격을 두고 나눠 삭제하는 방법도 있다고 한다.

## TRUNCATE - 전체를 빠르게 비우기

TRUNCATE는 테이블 구조는 유지한 채 모든 데이터를 한 번에 삭제한다.
DELETE와 다르게 조건을 줄 수 없으며, 내부적으로는 초기화에 가까운 동작이다.

`TRUNCATE`는 테이블의 구조는 그대로 유지한 채, 모든 데이터를 한 번에 삭제하는 명령어다.
`DELETE`처럼 행 단위가 아닌 전체 초기화에 가까운 동작이기 때문에 훨씬 빠르고 간단하다.

```sql
TRUNCATE TABLE 테이블명;

-- 예시: 테스트 완료 후 로그 테이블 초기화
TRUNCATE TABLE logs;
```

- 조건 없이 전체 데이터가 삭제된다.
  - `WHERE` 절을 지원하지 않으며, 일부 DBMS에서는 실행 전에 경고 없이 바로 삭제가 이루어진다.
- 대부분의 경우, 트랜잭션에 포함되지 않기 때문에 ROLLBACK이 불가능하다.
  - 실수로 실행하면 되돌릴 수 없으므로 운영 환경에서 사용 시 주의가 필요하다.
- 데이터만 삭제하고, 테이블 구조(컬럼, 인덱스, 제약조건)는 유지된다.
  - 대부분의 DBMS에서 `AUTO_INCREMENT` 값도 초기화된다.
- 로그를 최소한으로 기록하고, 데이터 페이지를 직접 초기화하는 방식이므로 `DELETE`보다 훨씬 빠르다.
  - 단, `외래 키 제약(Foreign Key)`이 있는 경우 실행이 제한되거나, CASCADE 설정에 따라 예상치 못한 연쇄 삭제가 발생할 수 있다.
    ```sql
    -- 외래 키 제약이 있는 경우 실행이 불가능할 수도 있다.
    TRUNCATE TABLE child_table; -- 부모 테이블과 연동되어 있으면 에러 발생 가능
    ```

### 언제 사용하면 좋을까?

- 테스트용 데이터, 로그 데이터 등 빠르게 전체를 지워야 할 때
- 테이블 구조는 유지하면서, 데이터만 깨끗하게 초기화하고 싶을 때
- 성능이 중요한 대량 삭제 작업을 빠르게 처리하고 싶을 때

## DROP - 구조까지 삭제하기

DROP은 테이블 자체를 제거한다.
데이터뿐 아니라, 테이블의 구조, 인덱스, 제약조건, 권한 등 모든 정의 정보가 함께 제거된다.

```sql
DROP TABLE 테이블명;

-- 예시: 더 이상 사용하지 않는 테이블 제거
DROP TABLE logs;
```

- 테이블 자체가 사라지기 때문에 복구할 수 없다.
  - `DELETE`나 `TRUNCATE`처럼 일부 복구가 가능한 구조가 아니므로, 운영 환경에서는 특히 신중하게 사용해야 한다.
  - 실수를 방지하려면 `DROP` 권한을 제한하거나, 사전에 백업을 해두는 것이 좋다.
- `TRUNCATE`와 같이 외래 키 제약이 있는 테이블에 대해 바로 실행하면 문제가 발생할 수 있다.
- 삭제된 테이블은 다시 생성하지 않으면 이후 어떤 쿼리에서도 참조할 수 없다.
  - 이로 인해 애플리케이션에서 런타임 오류가 발생할 수 있다.

### 언제 사용하면 좋을까?

- 더 이상 사용하지 않는 테이블을 정리할 때
- 테이블 구조 자체가 잘못 설계되어 처음부터 다시 만들고 싶을 때
- 테스트용으로만 사용된 테이블을 완전히 제거하고 싶을 때

## 논리적 삭제 - 실제로는 남겨두기

`논리적 삭제(Logical Delete)`는 데이터를 물리적으로 지우지 않고, 삭제된 것처럼 표시해두는 방식이다.
운영 환경에서는 삭제가 곧바로 이루어지지 않도록, `is_deleted`나 `deleted_at` 같은 플래그 컬럼을 활용해 논리적 삭제를 구현하는 경우가 많다.

```sql
-- 예시: deleted_at 컬럼을 이용한 논리적 삭제
UPDATE 테이블명
SET deleted_at = NOW()
WHERE 조건;
```

- 데이터는 여전히 테이블에 남아 있으므로, 복구나 감사(Audit)가 가능하다.
- 애플리케이션 단에서 `deleted_at IS NULL` 등의 조건을 추가해 삭제된 데이터를 숨기는 방식으로 동작한다.
- 반면, 테이블이 계속 커지므로 성능 관리나 주기적인 정리가 필요할 수 있다.
- [물리적 삭제 vs 논리적 삭제, 나의 생각](https://velog.io/@hyeok_1212/%EC%9E%90%EC%9B%90-%EC%82%AD%EC%A0%9C-%EC%9A%94%EC%B2%AD%EC%97%90-%EB%8C%80%ED%95%9C-%EC%9D%91%EB%8B%B5#%EB%AC%BC%EB%A6%AC%EC%A0%81-%EC%82%AD%EC%A0%9C-vs-%EB%85%BC%EB%A6%AC%EC%A0%81-%EC%82%AD%EC%A0%9C)

## 마무리

`지운다`는 말 안에는 여러 선택이 숨어 있었다.
각각은 비용과 리스크, 목적이 다르다.

- `DELETE`는 느리지만 정교하다. 트랜잭션의 보호 아래 조건부로 안전하게 삭제할 수 있다.
- `TRUNCATE`는 빠르지만 단순하다. 전체 삭제에 유용하지만, 복구는 거의 불가능하다.
- `DROP`은 구조까지 없앤다. 되돌릴 수 없으며, 가장 신중해야 한다.

SQL은 한 줄로 모든 것을 지울 수 있지만, 그 한 줄의 무게는 상당하다. 특히 운영 환경에서는 삭제는 되돌릴 수 없는 행위이기 때문에, 신중해야 한다.

## 생각해볼 부분

- 실제로는 논리적 삭제만 사용할까?
- 백업은 어떻게 할까?
- 대량 삭제 시 성능은 어떻게 관리할까?
  - 직접 실행하기 전까진 모르지 않을까?
