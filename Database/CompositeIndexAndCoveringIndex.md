# 다중 컬럼 인덱스와 커버링 인덱스 활용

`다중 컬럼 인덱스`는 여러 컬럼을 조합하여 인덱스를 생성하는 방법이다.
`커버링 인덱스`는 쿼리에서 필요한 모든 컬럼을 포함하는 인덱스로, 데이터베이스가 인덱스만으로 쿼리를 처리할 수 있게 한다.

## 다중 컬럼 인덱스(Composite Index, 복합 인덱스)

이름 그대로 두 개 이상의 컬럼을 조합하여 인덱스를 생성하는 방법이다.
복합 인덱스라고도 불린다.

### 왜 필요할까?

단일 컬럼 인덱스도 쿼리 성능 향상에 큰 도움이 된다.
하지만 실제 서비스에서는 하나의 조건만으로 데이터를 조회하는 경우가 드물다.
대부분의 쿼리는 `WHERE` 절에 여러 조건을 사용하거나, `ORDER BY` 절에 여러 컬럼을 기준으로 정렬하는 등 복합적인 조건을 사용한다.

예를 들어, 사용자 테이블에서 `region`과 `gender`를 동시에 조건으로 검색하는 쿼리를 생각해보자.

```sql
SELECT *
FROM users
WHERE region = 'Seoul' AND gender = 'Male';
```

만약 `region`에만 단일 인덱스가 있다면, 데이터베이스는 `region = 'Seoul'`인 데이터를 찾은 후, 해당 결과에서 `gender = 'Male'`인 데이터를 다시 한 번 필터링해야 한다.
이 과정에서 불필요한 디스크 I/O가 발생할 수 있다.

```sql
CREATE INDEX idx_users_region_gender ON users (region, gender);
```

이때 `region`과 `gender`를 함께 묶은 `다중 컬럼 인덱스`를 사용하면, 데이터베이스는 인덱스만으로 `region = 'Seoul'이면서 gender = 'Male'인 데이터`를 훨씬 빠르게 찾아낼 수 있다.
인덱스 내에서 이미 두 조건이 모두 만족하는 데이터를 효율적으로 찾을 수 있게 된다.

## 다중 컬럼 인덱스의 작동 방식

다중 컬럼 인덱스는 인덱스에 포함된 컬럼들의 순서에 따라 데이터를 정렬하여 저장한다.
예를 들어 (컬럼A, 컬럼B, 컬럼C)로 구성된 인덱스는 다음과 같이 정렬된다.

1. 컬럼A를 기준으로 1차 정렬합니다.
2. 컬럼A 값이 같은 경우, 컬럼B를 기준으로 2차 정렬합니다.
3. 컬럼B 값이 같은 경우, 컬럼C를 기준으로 3차 정렬합니다.

이러한 정렬 방식 덕분에 Prefix 매칭이 가능하다.
즉, 인덱스의 왼쪽부터 시작하는 컬럼들을 기준으로 쿼리 조건이 주어질 때 인덱스를 효율적으로 활용할 수 있다.

(컬럼A, 컬럼B, 컬럼C)로 만든 인덱스는 아래와 같은 쿼리에 유용하다.

- WHERE 컬럼A = '값'
- WHERE 컬럼A = '값' AND 컬럼B = '값'
- WHERE 컬럼A = '값' AND 컬럼B = '값' AND 컬럼C = '값'

하지만 `WHERE 컬럼B = '값'`처럼 중간 컬럼부터 조건을 사용하거나 `WHERE 컬럼C = '값'`처럼 마지막 컬럼부터 조건을 사용하면 인덱스가 활용되지 않거나 효율이 떨어진다.

인덱스의 컬럼 순서가 매우 중요하다는 점을 기억해야 한다.

## 언제 다중 컬럼 인덱스를 사용할까?

- `WHERE` 절에 여러 컬럼이 `AND` 조건으로 자주 사용될 때
- `ORDER BY` 절에 여러 컬럼을 기준으로 정렬하는 쿼리가 자주 발생할 때 (특히 `WHERE` 절과 함께 사용될 때)
- `조인(JOIN)` 조건으로 여러 컬럼이 사용될 때

### 다중 컬럼 인덱스 설계 시 고려 사항

다중 컬럼 인덱스를 설계할 때 가장 중요한 것은 바로 인덱스 컬럼의 순서다.
쿼리에서 가장 많이 선택되고, 값의 분포가 넓은 컬럼, 즉 `카디널리티(Cardinality)`가 높은 컬럼을 인덱스의 선두에 두는 것이 일반적인 원칙이다.

추가로 `= (동등 비교)` 조건이 있는 컬럼이 `범위 검색(LIKE, >, <)`보다 동등 비교가 인덱스를 더 효과적으로 활용할 수 있기 때문에 선두에 두는 것이 좋다고 한다.

> ### 카디널리티(Cardinality)
>
> 카디널리티는 데이터베이스에서 특정 컬럼에 포함된 중복되지 않는 값의 수를 의미한다. 예를 들어, 사용자 테이블에서 gender 컬럼은 남성, 여성 두 가지 값만 가지므로 카디널리티는 2다. 반면, region 컬럼은 서울, 부산, 제주 등 지역의 수에 따라 카디널리티가 훨씬 높아질 수 있다.

카디널리티가 높을수록(고유한 값이 많을수록) 해당 컬럼의 인덱스는 데이터를 더 효율적으로 필터링할 수 있다. 예를 들어 100만 명의 사용자 중 `gender = '남성'`인 사람을 찾는 것보다 `region = '서울'`인 사람을 찾는 것이 더 많은 데이터를 필터링할 가능성이 높고, `user_id = 'abc1234'`처럼 고유한 값을 찾는 것이 가장 효율적이다.

### 주의사항

기존 인덱스와 똑같이 너무 많이 생성하게 되면 디스크 공간을 낭비하고, 쓰기 작업의 성능을 저하시킬 수 있다.
또한, 잘못된 순서는 인덱스가 전혀 사용되지 않거나, 별로 도움을 주지 못할 수 있다.

따라서 단순히 인덱스를 많이 만드는 것보다는, 현재 서비스의 쿼리 패턴과 데이터 분포를 분석하여 최적의 순서를 찾고 지속적으로 관리해주는 것이 중요하다.
주기적으로 `실행 계획(Execution Plan)`을 확인하여 인덱스가 제대로 사용되고 있는지 검증하는 습관을 들이는 것이 좋겠다.

## 커버링 인덱스(Covering Index)

`커버링 인덱스`는 쿼리에서 `SELECT` 하는 컬럼, `WHERE` 절의 조건 컬럼, `ORDER BY` 절의 정렬 컬럼 등 쿼리 처리에 필요한 모든 컬럼을 인덱스 자체가 가지고 있는 경우를 말한다.
즉, 데이터베이스가 쿼리를 실행할 때 테이블의 실제 데이터 페이지에 접근할 필요 없이, 인덱스만으로 모든 정보를 얻어낼 수 있는 상태다.

일반적인 인덱스는 검색 조건을 만족하는 데이터의 위치를 알려주고, 데이터베이스는 그 위치로 이동하여 실제 데이터를 읽어온다. 이 과정을 `룩업(Lookup)`이라고 하는데, 커버링 인덱스는 룩업 과정이 필요 없어, 디스크 I/O를 최소화하여 쿼리 성능을 극대화할 수 있다.

## 커버링 인덱스 작동 방식

쿼리가 실행될 때, 데이터베이스 옵티마이저는 해당 쿼리에 필요한 모든 정보가 특정 인덱스 내에 존재하는지 확인한다.
만약 존재한다면, 옵티마이저는 테이블의 실제 데이터 페이지에 접근하는 대신, 인덱스 자체에서 필요한 모든 데이터를 추출하여 쿼리를 처리한다.

### 예시

```sql
SELECT id, name, email
FROM users
WHERE region = 'Seoul' AND gender = 'Male';
```

이 쿼리를 커버링하기 위해서는 (region, gender, id, name, email) 컬럼이 포함된 인덱스를 고려할 수 있다.

```sql
CREATE INDEX idx_users_cover ON users (region, gender) INCLUDE (id, name, email);
```

`INCLUDE`와 같은(또는 유사한) 구문을 사용하여 인덱스에 추가 컬럼을 포함시킬 수 있습니다.

### 언제 커버링 인덱스를 사용할까?

- 특정 쿼리가 매우 자주 실행되고, 해당 쿼리의 성능이 시스템 전체에 큰 영향을 미칠 때
- `SELECT` 하는 컬럼의 개수가 적고, `WHERE` 절 또는 `ORDER BY` 절의 컬럼과 함께 인덱스에 포함될 수 있을 때
- 조회(Read) 중심적인 쿼리가 많을 때

### 커버링 인덱스 설계 시 고려 사항

인덱스에 더 많은 컬럼이 포함되므로 인덱스 자체의 크기가 커져 디스크 공간을 많이 차지하고, 메모리에 로드될 때 더 많은 공간이 필요하다.

특정 쿼리 패턴에 최적화된 인덱스이므로, 쿼리 패턴이 자주 변경되거나 다양한 쿼리가 존재할 경우 여러 커버링 인덱스를 만들어야 할 수 있으며, 이는 관리 부담을 가중시킨다.

따라서 어떤 쿼리가 가장 자주 실행되는지, 어떤 컬럼들을 `SELECT` 하는지 등 쿼리 패턴을 정확히 분석하고 신중하게 설계해야 한다.
불필요한 커버링 인덱스는 오히려 시스템 전체 성능에 악영향을 미칠 수 있다.

## 생각해볼 부분

- 커버링 인덱스를 만들고 이를 관리하기 위한 방법은 무엇이 있을까?
  - 문서화?
- 실행 계획을 자주 확인해보는 습관을 가지면 좋을 것 같다.
