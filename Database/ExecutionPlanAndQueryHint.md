# 실행 계획과 쿼리 힌트

DBMS는 대량의 데이터를 안전하고 빠르게 관리하기 위해 쿼리를 최적화된 방식으로 실행해야 한다. 이를 위해 옵티마이저가 실행 계획을 수립하지만, 항상 최적은 아니므로 관리자는 실행 계획을 검토하고 조정할 필요가 있다. 이때, 쿼리 힌트를 활용하면 특정 실행 방식을 유도할 수 있다고 한다.

- [실행 계획(Execution Plan)](#실행-계획-execution-plan)
- [EXPLAIN](#explain)
- [쿼리 힌트(Query Hint)](#쿼리-힌트-query-hint)

## 실행 계획 (Execution Plan)

실행 계획은 DBMS가 쿼리를 처리하기 위해 선택한 구체적인 절차와 방법을 의미한다. 옵티마이저는 다양한 실행 계획 후보를 평가하여 비용이 가장 낮은 계획을 선택한다.

### 왜 실행 계획이 중요할까?

실행 계획은 쿼리 성능을 좌우하며, 비효율적인 계획은 애플리케이션 전체 성능 저하로 이어진다.

개발자가 원하는 방식으로 쿼리를 작성했다고 해도, `실제 실행은 옵티마이저가 선택한 경로를 따른다.` 이때 옵티마이저가 인덱스를 활용하지 못하거나 잘못된 경로를 고르면, 불필요한 풀 테이블 스캔이 발생해 성능이 크게 저하될 수 있다.

따라서 백엔드 개발자는 실행 계획을 확인하여 의도와 실제 실행이 일치하는지 검증하고, API 응답 지연의 원인을 찾아 병목 구간을 최적화함으로써 성능을 개선할 수 있다.

## EXPLAIN

`EXPLAIN`은 쿼리의 실행 계획을 보여주는 키워드다. 쿼리가 어떻게 실행될 것인지, 어떤 인덱스가 사용될 것인지 등을 미리 파악할 수 있다.

```sql
EXPLAIN
SELECT *
FROM users
WHERE age > 30;
```

추가로 `ANALYZE` 키워드를 사용하면, 더 상세한 정보를 확인할 수 있다.

```sql
EXPLAIN
ANALYZE
SELECT *
FROM users
WHERE age > 30;
```

### EXPLAIN 결과 해석

EXPLAIN을 포함한 쿼리를 실행하면 아래와 같은 컬럼을 조회할 수 있다.

| 컬럼              | 의미                                                                                                  |
| ----------------- | ----------------------------------------------------------------------------------------------------- |
| **id**            | SELECT 쿼리별 식별자. 서브쿼리나 UNION 시 유용                                                        |
| **select_type**   | 각 단위 SELECT 쿼리의 타입. `SIMPLE`, `PRIMARY`, `SUBQUERY` 등으로 표시                               |
| **table**         | 접근하는 테이블 이름                                                                                  |
| **type**          | **성능 지표의 핵심.** 각 테이블 레코드를 읽는 접근 방식. `ALL`, `range`, `ref`, `const` 순으로 효율적 |
| **possible_keys** | 쿼리 최적화기가 사용할 수 있다고 판단한 인덱스 목록                                                   |
| **key**           | 최종적으로 **선택된 인덱스**                                                                          |
| **key_len**       | 선택된 인덱스 키의 길이. 다중 컬럼 인덱스 사용 시 확인                                                |
| **ref**           | `key` 컬럼을 통해 레코드를 찾을 때 사용된 값 또는 컬럼                                                |
| **rows**          | **예측한 읽을 레코드 수.** 값이 낮을수록 효율적이다                                                   |
| **filtered**      | 해당 테이블에서 조건에 의해 필터링되고 남을 **예상 레코드 비율**                                      |
| **Extra**         | **쿼리 최적화기의 동작 힌트.** `Using filesort`, `Using temporary` 등 성능 문제를 암시하는 경고       |

### select_type

select_type은 SELECT 쿼리의 유형을 나타낸다. 서브쿼리, 파생 테이블(인라인 뷰), UNION 등 복잡한 쿼리를 해석할 때 유용하다.

- SIMPLE : 서브쿼리나 UNION이 없는 단순 SELECT
- PRIMARY : 서브쿼리를 포함하는 경우 가장 바깥쪽 SELECT
- SUBQUERY : SELECT나 WHERE 절 안에 포함된 서브쿼리
- DERIVED : FROM 절 안에 포함된 서브쿼리(파생 테이블, 인라인 뷰)
- UNION : UNION 문에서 두 번째 이후 SELECT
- DEPENDENT SUBQUERY : 외부 쿼리 컬럼에 의존하는 서브쿼리 (성능 저하 가능성 높음)

> ### 💡 TIP
>
> DEPENDENT SUBQUERY가 보인다면 조인으로 풀 수 있는지 고민해보는 게 좋다.

### type

type은 `접근 방식(access type)`을 의미하며, 옵티마이저가 테이블 레코드를 어떻게 읽는지 보여주는 지표라서 성능 판단의 핵심이다. 일반적으로 값이 제한적일수록(=더 선택적일수록) 성능이 좋다.

- system : 단 1개의 행만 존재 (가장 빠름)
- const : 프라이머리 키나 유니크 키를 상수 비교로 접근 (매우 효율적)
- eq_ref : 조인 시 프라이머리 키/유니크 키로 정확히 1행 매칭
- ref : 인덱스를 사용하지만 여러 행이 매칭될 수 있음
- range : 인덱스를 범위 조건으로 사용 (BETWEEN, <, >, IN 등)
- index : 인덱스 풀 스캔 (테이블 전체가 아니라 인덱스 전체 읽음)
- ALL : 풀 테이블 스캔 (가장 비효율적)

> ### 💡 TIP
>
> type 값이 ALL이나 index라면 대체로 성능 이슈 신호다. 인덱스 추가, 조건절 변경, 조인 순서 조정 등을 고려해야 한다.

### key

key는 실제로 사용된 인덱스를 보여준다.

- NULL : 인덱스를 사용하지 않음 (대부분 성능 문제 신호)
- 인덱스명 : 옵티마이저가 선택한 인덱스
- 다중 컬럼 인덱스일 경우 key_len을 함께 보면 몇 개 컬럼까지 활용했는지 알 수 있다.

> ### 💡 TIP
>
> possible_keys에는 인덱스 후보가 보이는데, key가 NULL이면 인덱스를 쓰지 못하고 있다는 뜻이다.

### rows

rows는 옵티마이저가 예측한 읽을 레코드 수이다.

- 값이 높을수록 많은 레코드를 읽는다는 뜻 → 성능 저하 가능성
- 실제 결과 건수와 차이가 크면 통계 정보가 최신이 아닐 수 있음 (ANALYZE TABLE 필요)

> ### 💡 TIP
>
> rows 값이 높으면 인덱스 추가, WHERE 절 조건 개선 등을 고려해야 한다.

### Extra

Extra는 옵티마이저의 추가 작업 정보를 보여준다. 여기에 나오는 키워드는 성능 분석의 중요한 힌트다.

- Using index : 커버링 인덱스 사용 (좋은 신호)
- Using where : WHERE 조건으로 필터링 발생 (일반적)
- Using temporary : 임시 테이블 생성 → 성능 저하 가능성
- Using filesort : 정렬 작업을 별도로 수행 → 성능 저하 가능성
- Using join buffer : 조인 최적화 실패, 버퍼 사용 → 성능 저하 가능성

> ### 💡 TIP
>
> Using temporary, Using filesort가 보이면 GROUP BY, ORDER BY, DISTINCT 구문 최적화를 고려해야 한다.

## 쿼리 힌트(Query Hint)

쿼리 힌트는 DBMS의 옵티마이저가 특정 실행 계획을 따르도록 강제 지시하는 방법이다. 실행 계획을 확인한 뒤 옵티마이저가 비효율적인 경로를 선택했다고 판단될 때 사용한다.

하지만 쿼리 힌트는 최후의 수단으로 사용한다고 한다. 옵티마이저가 대부분의 경우 개발자보다 더 나은 판단을 내리기 때문이다.

### 주요 쿼리 힌트와 사용법

쿼리 힌트는 주로 `SELECT` 문에 주석 형태로 작성한다.

```sql
SELECT /*+ INDEX(users idx_age) */
FROM users
WHERE age > 30;
```

`USE INDEX` / `FORCE INDEX`

- `USE INDEX`: 옵티마이저에게 특정 인덱스를 사용하도록 권장하는 힌트다. 옵티마이저가 인덱스를 사용하지 않는 것이 더 효율적이라고 판단하면 무시할 수 있다.
- `FORCE INDEX`: 옵티마이저에게 특정 인덱스를 강제로 사용하도록 지시하는 강력한 힌트다. 이 지시는 특별한 경우가 아니라면 반드시 따르게 된다.
- `IGNORE INDEX`: 옵티마이저에게 특정 인덱스를 사용하지 않도록 지시하는 힌트다. 인덱스에 결함이 있거나, 인덱스 사용 시 오히려 성능이 떨어지는 경우에 사용한다.

### 쿼리 힌트 주의사항

앞서 말한 것처럼 쿼리 힌트는 최후의 수단으로 사용해야 한다. 3~4개 이상의 유사한 인덱스가 존재해 옵티마이저가 혼동하거나, 옵티마이저가 잘못된 조인 순서를 선택해 성능이 크게 저하될 때, 데이터 분포나 업무 특성을 옵티마이저가 제대로 파악하지 못할 때 사용을 고려할 수 있다.

그러나...

- 쿼리 힌트는 특정 시점의 데이터 상태에 맞춰진 임시방편일 수 있다. 데이터의 양이나 분포가 변하면 힌트가 오히려 독이 되어 성능을 더 악화시킬 수 있으니 주의해야 한다.
  - 오늘의 최적화가 내일의 병목이 될 수 있다.
  - 데이터 증가에 따른 성능 변화 추적이 필요하다.
- 힌트가 포함된 쿼리는 다른 개발자가 봤을 때 왜 특정 인덱스를 강제했는지 파악하기 어렵다. 이는 코드의 가독성과 유지보수성을 해친다.
- EXPLAIN으로 성능 저하의 원인을 파악했다면, 쿼리 힌트를 사용하기보다 인덱스를 새로 추가하거나 쿼리 자체를 개선하는 것이 장기적으로 훨씬 바람직한 해결책이라고 한다.

## 마무리

지금까지는 단순하게 Full Table Scan을 피하고, 인덱스를 설정하는 정도로만 성능 최적화를 고려해왔다. 하지만 실제 운영 환경에서는 다양한 요소들이 복합적으로 작용하므로, 보다 정교한 접근이 필요함을 깨달았다. 다음에는 진행 중인 프로젝트에서 이러한 요소들을 어떻게 반영할 수 있을지 고민해봐야겠다.
