# B-트리와 B+트리 구조의 차이

B-트리와 B+트리는 데이터베이스와 파일 시스템에서 널리 사용되는 트리 구조다.

## 왜 데이터베이스에서 트리 구조를 사용할까?

데이터베이스에서 수백만 개의 레코드 중에서 특정 조건에 맞는 데이터를 빠르게 찾기 위해서는 [인덱스](./WhatIsIndex.md)가 필요하다. 인덱스는 책의 목차처럼 데이터가 어디에 저장되어 있는지 가리키는 포인터 역할을 한다.

이러한 인덱스를 구현하는 대표적인 자료구조가 바로 `B-트리`와 `B+트리`다.

```sql
-- 인덱스가 없다면, 레코드를 모두 확인 (Full Table Scan)
-- 인덱스가 있다면, 몇 번의 비교만으로 원하는 데이터 위치 찾기
SELECT * FROM users WHERE user_id = 12345;
```

대부분의 관계형 데이터베이스(MySQL, PostgreSQL, Oracle 등)는 기본 인덱스로 B+트리를 사용한다. 그 이유를 이해하기 위해 B-트리와 B+트리의 구조적 차이를 살펴보자.

## 시각적 이해를 위한 참고 자료

실제로 동작을 눈으로 볼 수 있는 도구가 있다. 직접 데이터를 삽입/삭제해볼 수 있다.

- [B-트리 눈으로 살펴보기](https://www.cs.usfca.edu/~galles/visualization/BTree.html)
- [B+트리 눈으로 살펴보기](https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html)

## B-트리와 B+트리 핵심 차이점 비교

| 구분                 | B-트리                     | B+트리                                         |
| -------------------- | -------------------------- | ---------------------------------------------- |
| **데이터 저장 위치** | 내부 노드와 리프 노드 모두 | 리프 노드에만 저장                             |
| **탐색 완료 지점**   | 내부 노드에서도 완료 가능  | 항상 리프 노드까지 진행                        |
| **노드 간 연결**     | 부모-자식 포인터만 존재    | 리프 노드 간 수평 연결 추가                    |
| **범위 쿼리 성능**   | 상대적으로 비효율적        | 매우 효율적                                    |
| **공간 효율성**      | 키와 데이터 모두 저장      | 내부 노드가 키만 저장하여 더 많은 키 수용 가능 |
| **구조 복잡도**      | 삽입/삭제 시 복잡한 재조정 | 상대적으로 단순한 구조                         |

## 상세 분석

### 1. 데이터 저장 방식의 차이

**B-트리**

```
     [10:data10, 20:data20]
     /         |           \
[5:data5]  [15:data15]  [25:data25, 30:data30]
```

`B-트리`에서는 위처럼 모든 노드에 키와 값이 함께 저장된다. 장점은 특정 키를 찾을 때 내부 노드에서 바로 데이터를 가져올 수 있어 빠른 접근이 가능하다는 것이다. 각 키는 한 번만 저장되므로 키 중복도 없다.

**B+트리**

```
내부 노드:        [       10,     20       ] (분리자 역할, 라우팅 정보)
               /            |             \
리프 노드: [5:d5] -> [10:d10, 15:d15] -> [20:d20, 25:d25, 30:d30]
```

`B+트리`는 내부 노드에는 분리자 역할을 하는 키만 저장하고, 실제 데이터는 모두 리프 노드에 저장한다. 내부 노드의 키는 "이 값 이상은 오른쪽으로 간다"는 라우팅 정보일 뿐이다. 내부 노드가 더 많은 키를 담을 수 있어 트리 높이가 낮아지고, 캐시 효율성이 높아져 전체적으로는 더 효율적이다.

### 2. 탐색 패턴의 일관성

`B+트리`는 모든 탐색이 리프 노드에서 끝나기 때문에 `일관된 성능`을 보장한다. 반면 `B-트리`는 데이터 위치에 따라 탐색 깊이가 달라질 수 있어 성능 예측이 어려울 수 있다.

데이터베이스 쿼리 최적화나 성능 튜닝을 할 때 고려해야 할 중요한 요소 중 하나가 바로 이 탐색 패턴의 일관성이다. B+트리는 항상 리프 노드까지 내려가야 하므로, 쿼리 실행 계획을 분석할 때도 예측 가능성이 높아진다.

### 3. 범위 쿼리 성능

```sql
SELECT * FROM users WHERE age BETWEEN 25 AND 35;
```

나이 범위를 조건으로 조회하는 쿼리를 생각해보자. `B-트리`에서는 25를 찾은 후 35까지의 모든 값을 찾기 위해 트리를 여러 번 순회해야 한다. 하지만 `B+트리`는 리프 노드가 연결되어 있어 25를 찾은 후 포인터를 따라 순차적으로 접근할 수 있다.

- `B-트리`: 범위 내 각 요소를 찾기 위해 반복적인 트리 순회가 필요하다.
- `B+트리`: 시작점을 찾은 후 연결된 리프 노드를 순차 탐색한다. 훨씬 효율적이다.

### 4. 공간 I/O 효율성

`B+트리`는 내부 노드에 키만 저장하므로 더 많은 키를 한 노드에 담을 수 있다. 이는 트리의 높이를 낮춰 `디스크 I/O` 횟수를 줄이는 효과가 있다.

같은 메모리 공간에서 `B-트리`는 키+데이터로 인해 더 적은 수의 키를 저장할 수 있고, `B+트리`는 키만 저장하므로 더 많은 키를 저장할 수 있기 때문에 더 낮은 트리 높이를 유지할 수 있게 되는 것이다. 덕분에 디스크 I/O가 줄어들고, 전체적인 검색 성능이 향상된다.

### 5. 삽입/삭제 연산의 복잡도

`B+트리`는 데이터 변경이 항상 리프 노드에서만 일어나므로 구조적으로 더 단순하고, `B-트리`는 내부 노드의 데이터도 고려해야 하므로 삽입/삭제 로직이 더 복잡해질 수 있다.

더 자세히 알아보면, `B+트리`는 리프 노드에서만 데이터가 추가/삭제되기 때문에, 내부 노드는 오직 키와 포인터만 재조정하면 되어 구조 변경이 상대적으로 간단하다. 반면, `B-트리`는 내부 노드에도 데이터가 있으므로 삽입/삭제 시 노드 분할이나 병합이 발생하면 더 복잡한 조정이 필요하다.

## 마무리

실제로 대부분의 현대 데이터베이스 시스템에서는 `B+트리`를 채택했다. 아마 웹 애플리케이션에서 흔히 사용하는 범위 쿼리, 정렬, 페이징 등의 작업에서 B+트리가 압도적으로 유리하기 때문인 것 같다.

## 생각해볼 부분

- 왜 일관적인 탐색 패턴이 데이터베이스 성능에 중요한가?
  - 모든 탐색이 리프 노드까지 도달해야 한다면, DBMS는 리프 노드 블록을 효율적으로 캐싱하여 다음 탐색에 재활용할 수 있을 것 같다. 반면, 탐색이 중간에 끝날 수 있는 B-트리의 경우, 어떤 노드가 자주 접근될지 예측하기 어렵기에 캐싱하기 어려운 구조가 아닐까?
- 노드 내의 요소 수(k)를 얼마로 설정할까?
  - 나아가 10억 건의 데이터가 있을 때, 높이가 어느 정도가 될까?
