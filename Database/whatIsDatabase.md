# 데이터베이스란?

데이터베이스는 여러 응용프로그램이나 사용자가 공동으로 사용할 수 있도록 체계적으로 통합된 데이터의 집합이다.
문서처럼 사람이 읽기 위해 저장한 것이 아니라, 전자적으로 디스크에 저장되며 프로그램이 효율적으로 접근하고 활용할 수 있도록 구성된다.

- [파일에 저장해도 되는거 아니에요? 왜 DB를 쓰시나요?](#파일에-저장해도-되는거-아니에요-왜-db를-쓰시나요)
- [DB와 DBMS의 차이](#db와-dbms의-차이)
- [다양한 유형의 DBMS](#다양한-유형의-dbms)
- [생각해볼 부분](#생각해볼-부분)

## 데이터?

> 데이터가 모이면 정보가 되고, 정보가 모이면 지식이 된다.

- 예시: 오전 8시부터 9시 사이, 서울 강남대로를 통과한 차량 수는 2,500대였다. (데이터)
- `정보(Information)`는 데이터에 의미를 부여해 해석한 것이다.
  - 예시: 이 시간대의 교통량은 평소보다 약 20% 더 많은 것으로 나타났다.
- `지식(Knowledge)`은 정보들을 종합하여 상황을 이해하고 판단하는 단계이다.
  - 예시: 매주 월요일 출근 시간대에는 혼잡이 반복된다는 점을 근거로, 우회 도로나 대중교통을 안내하는 정책을 마련할 수 있다.

## 파일에 저장해도 되는거 아니에요? 왜 DB를 쓰시나요?

> "그냥 텍스트 파일에 저장하면 안 돼요? 요즘은 엑셀도 잘 되어 있고, 파일로도 관리 가능하잖아요?"

이 질문은 실제로도 꽤 설득력 있게 들린다. 나 역시 처음엔 그렇게 생각했었다.
하지만 데이터가 많아지고, 여러 사용자가 동시에 접근하거나, 복잡한 조건으로 데이터를 다루기 시작하면 단순한 `파일 시스템(File System)`만으로는 한계가 드러난다.

### 여러 명이 동시에 접근하면?

`users.csv` 파일에 회원 정보를 저장한다고 가정하자.
한 명이 파일을 열고 정보를 추가하고 있는 동안, 다른 누군가도 동시에 파일을 열어 수정한다면 `동시 수정`으로 인해 저장이 꼬이거나 데이터가 유실될 수 있다.
또한 누가 마지막으로 저장했는지 확인할 방법이 없다. (스프레드 시트에는 수정 로그가 있던데, 그냥 txt 파일이라고 생각하면 어려울 것이다.) 데이터베이스 사용 집단이 커질수록 이 문제는 커질 것이다.

반면, 데이터베이스는 `트랜잭션`과 `동시성 제어`를 통해 여러 사용자가 동시에 데이터를 수정해도 충돌 없이 안전하게 처리할 수 있다.

### 사용자 마음대로 입력되는 데이터들

파일은 형식에 구애받지 않고 누구나 마음대로 작성할 수 있다.
예를 들어, 텍스트 파일로 회원 정보를 저장할 때 누군가는 생년월일을 `2000/01/01`, 누군가는 `2000년 1월 1일`이라고 쓰더라도 파일은 이를 막을 방법이 없다. 즉, 데이터를 저장하는 목적 중 가장 큰 조회(검색)를 하기 매우 힘들어진다. (형식이 제각각이면 원하는 데이터를 찾거나 통계를 내기가 매우 어려워진다.)

데이터베이스는 `스키마(schema)`를 통해 `생년월일은 반드시 yyyy-MM-dd 형식의 날짜`처럼 데이터 형식과 규칙을 강제할 수 있다.

### 파일은 검색과 조회에 비효율적이다.

파일은 전부 순회하면서 찾아야 하기 때문에 데이터가 많아질수록 찾는 시간이 선형적으로 증가한다.
조건이 복잡할수록 코드도 복잡해지고, 느려지고, 오류가 나기 쉽다.

데이터베이스는 `인덱스`를 사용해서 필요한 데이터를 빠르게 찾을 수 있다.

### 파일은 데이터 무결성(정합성)을 보장하지 않는다

예를 들어, 상품 테이블에서 상품 ID 101번이 존재하지도 않는데 주문 테이블에 101번 상품 주문이 들어간다면, 파일 기반인 경우 이를 막을 수 없다.
즉, 파일 시스템을 활용하면, 누군가 잘못된 데이터를 넣더라도, 검증하거나 방지할 방법이 없다.

데이터베이스는 `외래키(Foreign Key)`, `제약조건(Constraint)` 등을 활용하여 `존재하지 않는 상품은 주문할 수 없다`는 규칙을 시스템 차원에서 보장한다.

### 그래서 무조건 DB를 쓰라는거야?

무조건은 아니다.

간단한 설정 정보, 로그 기록, 데이터가 소량이고 변경이 거의 없는 경우에는 파일 기반 저장도 문제가 없을 수 있다.
하지만 데이터가 커지고 여러 사람이 함께 사용하고, 검색, 정합성, 보안 등이 중요해지는 순간 데이터베이스가 대부분 최선의 선택이 될 것이다.

| 항목              | 파일 기반                                  | 데이터베이스                             |
| ----------------- | ------------------------------------------ | ---------------------------------------- |
| **동시 접근**     | 여러 명이 동시에 접근하면 충돌 위험이 있다 | 동시성 제어로 충돌 없이 데이터 수정 가능 |
| **데이터 형식**   | 형식이 제각각이면 검색하기 어렵다          | 스키마로 데이터 형식 강제할 수 있다      |
| **검색 효율성**   | 데이터 검색이 순차적으로 이루어진다        | 인덱스로 데이터 검색이 효율적이다        |
| **데이터 무결성** | 데이터의 무결성을 보장하기 어렵다          | 참조 무결성으로 일관된 데이터 유지       |

## DB와 DBMS의 차이

`DB(Database)`와 `DBMS(Database Management System)`는 비슷하게 들리지만 서로 다른 개념이다. 소통할 때는 둘을 구분하지 않고 그냥 `DB`라고 부르기도 하지만, 학습 단계에서는 명확히 구분해서 이해하는 것이 중요할 것 같다.

| 용어                                | 설명                                                                        |
| ----------------------------------- | --------------------------------------------------------------------------- |
| **DB (데이터베이스)**               | 구조화된 데이터를 체계적으로 모아놓은 저장소. 즉, **데이터 그 자체**        |
| **DBMS (데이터베이스 관리 시스템)** | 데이터베이스를 생성하고, 관리하고, 접근할 수 있도록 도와주는 **소프트웨어** |

문서들을 보관하는 캐비닛을 예로 들어보자.
DB는 캐비닛 속의 문서들이고, DBMS는 이 문서를 꺼내고, 분류하고, 정리해주는 사서나 관리자라고 생각할 수 있다.

대표적인 DBMS로는 MySQL, Oracle, MongoDB 등이 있다.

### DBMS의 주요 기능

| 기능                                 | 설명                                                  |
| ------------------------------------ | ----------------------------------------------------- |
| **DDL (Data Definition Language)**   | 데이터베이스 구조 정의 (예: 테이블 생성, 컬럼 정의)   |
| **DML (Data Manipulation Language)** | 데이터 조회, 삽입, 수정, 삭제                         |
| **DCL (Data Control Language)**      | 사용자 권한 설정, 접근 제어                           |
| **트랜잭션 관리**                    | 여러 작업을 하나의 단위로 처리하여 데이터 일관성 보장 |

정리하면, `DB`는 데이터를 저장하는 **공간**, `DBMS`는 데이터를 다루는 **도구**라고 볼 수 있다.

## 다양한 유형의 DBMS

DBMS는 데이터 저장 방식과 사용 목적에 따라 여러 가지 유형으로 나뉜다.  
각 DBMS는 처리 방식, 확장성, 사용 용도에 따라 장단점이 다르다.

### 관계형 DBMS (RDBMS)

- `데이터를 테이블 형태`로 저장하며, 각 테이블은 서로 `관계`를 가진다.
- `SQL (Structured Query Language)`을 사용해 데이터에 접근한다.
- 스키마(테이블 구조)가 엄격하게 정의된다.
  - 엄격한 스키마로 인해 구조 변경이 필요할 때 기존 데이터 마이그레이션이 복잡하고 위험할 수 있다.
- `트랜잭션`을 지원하며, ACID 특성을 보장한다.
  - 원자성(Atomicity): 트랜잭션 내 모든 연산은 전부 성공하거나 전부 실패한다.
  - 일관성(Consistency): 트랜잭션 전후로 데이터베이스는 일관된 상태를 유지한다.
  - 격리성(Isolation): 동시에 실행되는 트랜잭션들이 서로 영향을 주지 않는다.
  - 지속성(Durability): 완료된 트랜잭션의 결과는 영구적으로 반영된다.
- 복잡한 JOIN 쿼리와 정형화된 데이터 처리에 강하다.
  - 엄청난 양의 데이터가 존재하는 경우 조인 연산 등이 크게 느려질 수 있다.

대표 시스템: MySQL, PostgreSQL, Oracle

### NoSQL DBMS

- `비(非)관계형 데이터베이스`로, 정해진 스키마 없이 유연하게 데이터를 저장한다.
- ACID보다 확장성, 속도, 유연성에 초점을 맞춘다.
  - NoSQL은 일반적으로 [CAP 이론](https://www.analyticsvidhya.com/blog/2020/08/a-beginners-guide-to-cap-theorem-for-data-engineering/)에 따라 일관성보다는 가용성과 확장성을 우선하는 구조를 취한다.
- 대용량의 분산 시스템이나 실시간 처리 시스템, 구조가 자주 바뀌는 데이터 구조에 적합하다.
- 수평 확장(서버 추가) 용이하다.

| 유형                    | 설명                                     | 대표 DB          |
| ----------------------- | ---------------------------------------- | ---------------- |
| **문서형 (Document)**   | JSON 문서처럼 구조화된 데이터를 저장     | MongoDB, CouchDB |
| **키-값형 (Key-Value)** | 키 하나에 값 하나를 저장 (딕셔너리 형태) | Redis, DynamoDB  |
| **컬럼형 (Column)**     | 대량의 컬럼 데이터를 효율적으로 저장     | Cassandra, HBase |
| **그래프형 (Graph)**    | 노드와 간선으로 데이터 간의 관계 표현    | Neo4j, ArangoDB  |

### 인메모리 DBMS

- 데이터를 `디스크 대신 메인 메모리(RAM)`에 저장하는 방식.
  - 시스템 종료 시 데이터가 사라질 수 있다. (옵션에 따라 영속화 가능하다고 한다.)
  - RAM은 디스크보다 비싸므로 대용량 데이터 저장에 비용이 많이 든다.
- 디스크 I/O가 없어서 매우 빠른 속도를 보여준다.
- 주로 `캐시 시스템`이나 `세션 저장소`로 사용된다.

대표 시스템: Redis, Memcached

### 왜 다양한 DBMS를 알아야 할까?

항상 MySQL 같은 RDBMS만 사용했었다.
그러나 각각의 특징을 조금만 알아보니, 실시간성이 중요한 경우 NoSQL DBMS를 고려한다거나 휘발되어도 큰 문제가 없고 캐싱으로 빠른 속도가 필요한 경우 인메모리 DBMS를 선택하는 등 이처럼 DBMS의 유형과 특성을 이해하면, 프로젝트의 목적과 성격에 맞는 최적의 데이터 저장 방식을 선택할 수 있을 것 같다.

각 DBMS 유형의 한계를 이해하는 것은 프로젝트 요구사항에 맞는 최적의 선택을 하거나, 때로는 여러 유형을 조합해 각각의 한계를 상호 보완하는 접근을 채택하면 좋을 것 같다. `만능 데이터베이스`는 없으며, 적절한 트레이드오프를 고려한 선택이 필요하다고 정리할 수 있다.

## 생각해볼 부분

통상 여러 사용자가 한 `DBMS`에 동시 접근해 사용한다.

- DB에 저장되는 자료는 주로 `2차 메모리(디스크)`에 저장되므로 영속성은 보장되지만 속도는 메인 메모리보다 느리다.
- 여러 사용자의 동시 접근을 처리하기 위한 네트워크 서버 구조가 필요하다.
- 극단적인 `동시성 이슈`가 발생할 가능성이 높다.
- 많은 요청이 몰릴 경우 `I/O 병목현상`으로 인한 성능저하 가능성이 높다.
