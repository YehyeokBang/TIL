# RDBMS와 관계형 모델의 기본 개념

[이전 글(데이터베이스란?)](WhatIsDatabase.md)에서 간단하게 DBMS에 대한 내용과 유형에 대해 학습했다.
이번에는 그중에서 RDBMS에 대해 학습하려고 한다.

- [관계형 모델?](#관계형-모델)
- [관계형 모델의 기본 철학](#관계형-모델의-기본-철학)
- [릴레이션의 구조](#릴레이션relation의-구조)
- [왜 관계형이라고 부를까?](#왜-관계형이라고-부를까)
- [관계형 모델의 이론적 기반](#관계형-모델의-이론적-기반)
- [ACID 특성](#acid-특성)
- [관계형 모델의 장단점](#관계형-모델의-장단점)

## RDBMS?

`RDBMS(Relational Database Management System)`는 데이터를 `2차원 테이블` 형태로 저장하고 관리하는 데이터베이스 시스템이다. 각 테이블은 `행(Row)`과 `열(Column)`로 구성되며, SQL(Structured Query Language)을 통해 데이터를 정의, 조작, 질의할 수 있다.

RDBMS는 `관계형 모델(Relational Model)`을 기반으로 구현되며, 다양한 테이블 간의 관계를 정의하고 이를 효율적으로 탐색 및 조작할 수 있도록 한다.

즉, 관계형 모델을 실제로 구현한 DBMS를 말한다.

대표적인 RDBMS: MySQL, PostgreSQL, Oracle DB, Microsoft SQL Server 등

## 관계형 모델?

RDBMS의 기반이 되는 것이 바로 `관계형 모델(Relational Model)`이다.

먼저, `관계형 모델(Relational Model)`은 여러 `데이터 모델(Data Model)` 중 하나로, 데이터 모델은 데이터베이스에 있는 데이터를 표현하는 개념의 집합이다.

데이터를 저장할 때 `어떻게 구조화해서 저장할까?`라는 질문에 답해주는 개념이 `데이터 모델(Data Model)`이다. 이러한 모델은 데이터가 어떤 형태로 표현될지, 어떤 방식으로 서로 연결될지를 정의한다.

관계형 모델은 여러 가지 데이터 모델 중 하나일 뿐이다. (그 외에도 계층형, 네트워크형, 객체지향형 등이 있다고 한다.)

## 관계형 모델의 기본 철학

관계형 모델은 1970년, IBM의 에드거 커드가 처음 제안했다.
에드거 커드는 관계형 모델의 핵심 원칙 세 가지를 제시했다.

### 1. 단순한 자료구조를 사용하라. (2차원 테이블)

데이터는 포인터 기반의 복잡한 연결 구조가 아닌, `2차원 테이블(릴레이션)`로 표현되어야 한다. 덕분에 사용자는 데이터를 보다 직관적으로 이해할 수 있다.

| 회원ID | 이름 | 이메일            |
| ------ | ---- | ----------------- |
| 1      | 벨로 | `bello@email.com` |
| 2      | 네오 | `neo@email.com`   |

### 2. 고수준 언어로 데이터에 접근하자 (SQL)

데이터를 조작할 때는 SQL과 같은 고수준의 선언형 언어를 사용한다. 사용자는 `무엇을 할 것인지`만 지정하고, `어떻게 수행할지`는 시스템이 처리한다.

```sql
-- 단순 조회
SELECT 이름
FROM 회원
WHERE 이메일 LIKE '%email.com';

-- 테이블 조인 예시
SELECT 회원.이름, 주문.상품명
FROM 회원
JOIN 주문 ON 회원.회원ID = 주문.회원ID
WHERE 회원.이름 = '벨로';
```

### 3. 저장 방식은 신경 쓰지 말자

사용자는 데이터의 물리적 저장 방식(파일 위치, 저장 순서 등)에 대해 알 필요가 없다. 데이터의 논리적 구조에만 집중하면 되고, 물리적 최적화는 시스템이 담당한다.

## 릴레이션(Relation)의 구조

관계형 모델의 핵심 단위는 `릴레이션(Relation)`이다. 보통 하나의 `테이블`을 의미한다.

| 용어              | 설명                                        |
| ----------------- | ------------------------------------------- |
| 튜플(Tuple)       | 릴레이션의 한 행(Row), 하나의 데이터 레코드 |
| 속성(Attribute)   | 릴레이션의 각 열(Column), 데이터의 속성     |
| 도메인(Domain)    | 속성이 가질 수 있는 값들의 집합             |
| 차수(Degree)      | 릴레이션의 열 수                            |
| 기수(Cardinality) | 릴레이션의 행 수                            |

각 데이터 항목은 명확하게 정의되고, 여러 릴레이션 간의 관계를 쉽게 파악할 수 있다.

## 왜 관계형이라고 부를까?

릴레이션은 단순한 테이블 그 자체로도 의미를 갖지만, `다른 릴레이션과의 관계(Relation)`를 활용하여 복잡한 정보를 표현할 수 있다.
이와 같은 릴레이션 사이의 연관성이 관계형 모델의 핵심이라고 할 수 있다.

예를 들어, 회원 테이블과 주문 테이블이 있다고 가정하자.  
회원 테이블은 사용자 정보를, 주문 테이블은 상품 주문 정보를 담는다.

```
회원 테이블: 회원 ID, 이름, 이메일
주문 테이블: 주문 ID, 회원 ID, 상품명

회원ID (회원) <----> 회원ID (주문)
```

공통 속성인 `회원 ID`를 기준으로 두 테이블을 연결하여 어떤 사용자가 어떤 상품을 주문했는지 확인할 수 있다.

이러한 관계는 `기본 키(Primary Key)`와 `외래 키(Foreign Key)` 개념을 통해 맺어진다.

- 기본 키는 각 테이블의 행을 고유하게 식별하는 값 (예: 회원 테이블의 회원 ID)
- 외래 키는 다른 테이블의 기본 키를 참조하는 속성 (예: 주문 테이블의 회원 ID)

아래처럼 하나의 테이블에 모든 정보를 다 넣으면 데이터의 중복이 발생한다.

| 회원 ID | 이름 | 이메일            | 주문 ID | 상품명 |
| ------- | ---- | ----------------- | ------- | ------ |
| 1       | 벨로 | `bello@email.com` | 101     | 키보드 |
| 1       | 벨로 | `bello@email.com` | 102     | 마우스 |

만약 이메일이 변경된다면, 모든 행을 수정해야 한다.
이러한 중복은 관리가 어렵고, 오류 발생 가능성도 높아진다.

그래서 관계형 데이터베이스에서는 테이블을 아래처럼 분리하고, 각 테이블 간의 관계를 형성한다.

**회원 테이블**

| 회원 ID | 이름 | 이메일            |
| ------- | ---- | ----------------- |
| 1       | 벨로 | `bello@email.com` |

**주문 테이블**

| 주문 ID | 회원 ID | 상품명 |
| ------- | ------- | ------ |
| 101     | 1       | 키보드 |
| 102     | 1       | 마우스 |

이제 회원 정보가 한 번만 저장되고, 주문 테이블은 해당 회원의 ID만 참조하면 된다.  
`테이블 간의 관계`를 통해 중복을 제거하고, 데이터의 일관성과 유지보수성을 높일 수 있다.

위와 같은 과정을 `정규화(Normalization)`라고 부른다.

결론적으로, 관계형 데이터베이스는 단순한 테이블 집합이 아니라, 테이블 간의 관계를 통해 복잡한 데이터를 효율적으로 표현하고 관리할 수 있는 구조를 가지기 때문에 `관계형`이라는 이름이 붙었다고 한다.

## 관계형 모델의 이론적 기반

관계형 모델은 단지 테이블 형태라고 할 수 있다. 아래의 원칙들에 기반해 데이터의 일관성과 정합성을 유지한다.

- `정규화(Normalization)`: 데이터를 중복 없이 구조화하기 위한 일련의 설계 기법이다. 이상현상(삽입/삭제/갱신 이상)을 방지하고 데이터 무결성을 높인다.
- `무결성 제약(Integrity Constraints)`: 데이터 간의 논리적 일관성을 강제한다. 예를 들어, 기본키(Primary Key), 외래키(Foreign Key), NOT NULL, UNIQUE 등이 있다.

## ACID 특성

RDBMS는 데이터의 신뢰성과 일관성을 보장하기 위해 `ACID` 특성을 준수한다. ACID는 `트랜잭션(Transaction)`의 네 가지 핵심 특징을 나타낸다.

### 원자성(Atomicity)

트랜잭션에 포함된 모든 연산은 모두 성공하거나 모두 실패해야 한다. 즉, 중간이 없다.

계좌에서 돈을 인출하고 다른 계좌로 입금하는 전체 거래가 하나의 원자 단위로 처리된다. 만약 중간에 오류가 발생하면 모든 변경사항이 취소(롤백)된다.

```sql
BEGIN TRANSACTION;
    UPDATE 계좌 SET 잔액 = 잔액 - 1000 WHERE 계좌번호 = '123';
    UPDATE 계좌 SET 잔액 = 잔액 + 1000 WHERE 계좌번호 = '456';
COMMIT;
```

### 일관성(Consistency)

트랜잭션 전후로 데이터베이스는 항상 일관된 상태를 유지해야 한다. 무결성 제약조건이 지켜져야 한다.

모든 계좌 잔액은 0 이상이어야 한다는 규칙이 있다면, 어떤 트랜잭션 후에도 이 규칙은 위반할 수 없다.

### 격리성(Isolation)

동시에 실행되는 여러 트랜잭션은 서로 영향을 미치지 않아야 한다.

사용자 A와 사용자 B가 동시에 같은 계좌에 접근하더라도, 각각의 트랜잭션은 다른 트랜잭션의 중간 상태를 볼 수 없다.

```sql
-- 격리 수준 설정 예시
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

### 지속성(Durability)

트랜잭션이 성공적으로 완료되면, 그 결과는 시스템 장애가 발생하더라도 영구적으로 보존되어야 한다.

은행 거래가 완료된 후 데이터베이스 서버가 다운되더라도, 재시작 후에도 해당 거래 기록은 남아있어야 한다.

ACID 특성은 관계형 데이터베이스의 신뢰성을 보장하는 핵심 요소이다.

## 관계형 모델의 장단점

| 구분                    | 내용                                                                 |
| ----------------------- | -------------------------------------------------------------------- |
| ✅ 장점                 |                                                                      |
| 데이터 일관성           | 정규화를 통해 데이터 중복을 줄이고 일관성을 유지할 수 있다.          |
| 표준화된 질의 언어(SQL) | SQL을 통해 직관적으로 데이터를 다룰 수 있다.                         |
| 관계 표현의 명확성      | 명시적인 외래 키와 조인을 통해 데이터 간의 관계를 잘 표현할 수 있다. |
| ACID 준수               | 트랜잭션을 통한 데이터 무결성과 일관성을 보장한다.                   |
| 확장성과 신뢰성         | 트랜잭션, 동시성 제어 등 견고한 기능을 갖추고 있다.                  |
| ❌ 단점                 |                                                                      |
| 스키마의 엄격성         | 유연한 스키마 구조를 갖기 어려워 빈번한 변경이 필요한 경우 불리하다. |
| 수평적 확장에 취약      | NoSQL에 비해 수평 확장(distributed scaling)이 어렵다.                |
| 복잡한 조인 성능 저하   | 조인이 많은 경우 성능 이슈가 발생할 수 있다.                         |
| 반정형/비정형 데이터    | JSON, 텍스트, 미디어 등의 처리에 NoSQL보다 효율성이 떨어진다.        |

## 마무리

매번 당연하게 RDBMS를 사용했지만, 그 배경에 대해 깊이 생각해보지 않았다.
관계형 모델의 기본 철학과 ACID 특성, 정규화의 필요성 등을 이해하니 RDBMS를 사용하는 이유가 조금은 명확해졌다.

물론 RDBMS가 모든 상황에 적합한 것은 아닐 것이다.

## 생각해볼 부분

- RDBMS는 어떤 상황에서 사용해야 할까?
- 완벽한 정규화는 데이터 중복을 제거하지만, 조회 시 많은 조인이 필요하지 않을까?
- 정규화, 격리 수준에 대해 더 알아보자.
