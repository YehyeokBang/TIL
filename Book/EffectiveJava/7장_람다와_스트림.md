# 7장 람다와 스트림

자바 8에서 함수형 인터페이스, 람다, 메서드 참조라는 개념이 추가되었다. 덕분에 함수 객체를 더 쉽게 만들 수 있게 되었고, 이와 함께 스트림 API까지 추가되어 데이터 원소의 시퀀스 처리를 라이브러리 차원에서 지원하기 시작했다. 이번 장에서는 이 기능들을 효과적으로 사용하는 방법을 알아본다.

- [아이템 42. 익명 클래스보다는 람다를 사용하라](#아이템-42-익명-클래스보다는-람다를-사용하라)
- [아이템 43. 람다보다는 메서드 참조를 사용하라](#아이템-43-람다보다는-메서드-참조를-사용하라)
- [아이템 44. 표준 함수형 인터페이스를 사용하라](#아이템-44-표준-함수형-인터페이스를-사용하라)
- [아이템 45. 스트림은 주의해서 사용하라](#아이템-45-스트림은-주의해서-사용하라)
- [아이템 46. 스트림에서는 부작용 없는 함수를 사용하라](#아이템-46-스트림에서는-부작용-없는-함수를-사용하라)
- [아이템 47. 반환 타입으로는 스트림보다 컬렉션이 낫다](#아이템-47-반환-타입으로는-스트림보다-컬렉션이-낫다)
- [아이템 48. 스트림 병렬화는 주의해서 적용하라](#아이템-48-스트림-병렬화는-주의해서-적용하라)

## 아이템 42. 익명 클래스보다는 람다를 사용하라

> ### 핵심 정리
>
> 익명 클래스는 함수형 인터페이스가 아닌 타입의 인스턴스를 만들 때만 사용하자. 람다는 코드를 더 간결하게 만들어주고, 익명 클래스를 사용할 때 발생하는 자잘한 실수를 줄여준다. 또한, 함수형 인터페이스의 인스턴스를 만드는 코드를 더 읽기 쉽게 만들어준다. 그러나 람다는 이름이 없고 문서화도 못하며, 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 사용하지 않는 편이 좋다. this 키워드를 사용할 수 없다는 점도 주의해야 한다.

예전 자바에서는 함수 타입을 표현할 때 추상 메서드를 하나만 담은 인터페이스(드물게는 추상 클래스)를 사용했으며, 그것들을 함수 객체(function object)라고 불렀다.

```java
// 익명 클래스의 인스턴스를 함수 객체로 사용 - 낡은 기법이다!
Collections.sort(words, new Comparator<String>() {
    public int compare(String s1, String s2) {
        return Integer.compare(s1.length(), s2.length());
    }
});
```

위 코드는 익명 클래스를 사용해 `Comparator` 인터페이스의 인스턴스를 만들어 `sort` 메서드에 넘겨주는 코드이다. 그러나 이 방식은 너무 길기 때문에 자바는 함수형 프로그래밍에 적합하지 않았다.

자바 8에서는 추상 메서드 하나만 존재하는 인터페이스가 함수형 인터페이스라는 것을 명확히 하고, 람다식을 이용해 함수형 인터페이스의 인스턴스를 만들 수 있게 되었다.

```java
// 람다식을 함수 객체로 사용 - 익명 클래스 대체
Collections.sort(words,
        (s1, s2) -> Integer.compare(s1.length(), s2.length()));
```

람다는 함수나 익명 클래스와 개념은 비슷하지만 코드는 훨씬 간결한 것을 볼 수 있다. 코드를 보면 매개변수와 반환값의 타입을 명시하지 않았다. 이는 컴파일러가 문맥을 살펴 타입을 추론하기 때문이다. (상황에 따라 컴파일러가 추론하지 못하는 경우가 있는데, 그때는 명시적으로 타입을 지정해주어야 한다.)

람다 자리에 비교자 생성 메서드를 사용하면 더 간결해질 수 있다.

```java
// 람다식을 함수 객체로 사용 - 더 간결하다!
Collections.sort(words, comparingInt(String::length));
```

더 나아가 자바 8때 List 인터페이스에 추가된 sort 메서드를 이용하면 더 간결해진다.

```java
// 더 간결한 람다식을 함수 객체로 사용
words.sort(comparingInt(String::length));
```

람다를 언어 차원에서 직접 지원하면서 기존에는 적합하지 않았던 곳에서도 함수 객체를 실용적으로 사용할 수 있게 되었다.

간결해진다고 무조건 람다가 좋은 것은 아니다. 우선 람다는 이름이 없고 문서화도 불가능하다. 따라서 코드 자체로 동작이 명확히 설명되지 않거나 코드 줄 수가 많아지면 람다를 사용하지 않는 편이 좋다. 또한, 람다는 자신을 참조할 수 없다. 따라서 람다에서 `this` 키워드는 바깥 인스턴스를 가리킨다. 즉, 함수 객체가 자신을 참조해야 한다면 익명 클래스를 사용해야 한다.

마지막으로 람다를 직렬화하는 일은 피해야 한다. 람다도 익명 클래스처럼 직렬화 형태가 구현별로 다를 수 있기 때문이다. 직렬화해야 하는 함수 객체가 있다면 private 정적 중첩 클래스의 인스턴스를 사용하자.

## 아이템 43. 람다보다는 메서드 참조를 사용하라

> ### 핵심 정리
>
> 메서드 참조는 람다를 아주 간단하게 만들어준다. 메서드 참조 쪽이 짧고 명확하다면 메서드 참조를 사용하고, 그렇지 않을 때만 람다를 사용하자.

익명 클래스보다 람다가 나은 점 중에서는 간결함이 크다고 볼 수 있다. 그런데 자바에서는 함수 객체를 람다보다 더 간결하게 만들 수 있는 방법을 제공한다. 바로 메서드 참조(method reference)이다.

메서드 참조는 `::` 연산자를 사용해 기존 메서드 구현을 재사용하고 직접 전달하는 람다보다 간결하게 표현할 수 있다.

```java
// 람다식을 함수 객체로 사용 - 익명 클래스 대체
List<String> playerNames = List.of("벨로", "머랭", "도기", "슬링키");
playerNames.forEach(name -> System.out.println(name));

// 메서드 참조를 사용하면 더 간결하다!
playerNames.forEach(System.out::println);
```

위 코드에서는 매개변수가 하나지만, 매개변수의 개수가 많아질수록 메서드 참조가 더 간결해진다. 또한, 메서드 참조는 람다보다 읽기 쉽고 직관적이다. 그러나 어떤 람다에서는 매개변수명 자체가 다른 개발자에게 좋은 가이드가 되기도 한다. 이런 경우에는 람다를 사용하는 편이 좋을 수도 있다.

또한, 클래스명이 너무 길어서 오히려 간결해지지 못할 수도 있다.

```java
// 메서드 참조 - 클래스명이 길어 가독성이 떨어진다.
service.execute(GoshThisClassNameIsHumongous::action);

// 람다 - 클래스명이 길어도 람다는 간결하다.
service.execute(() -> action());
```

상황에 맞게 가능한 방법 중에서 간결함, 팀원과의 합의 등을 고려해 메서드 참조와 람다를 사용하자.

## 아이템 44. 표준 함수형 인터페이스를 사용하라

> ### 핵심 정리
>
> 이제 자바를 사용할 때는 람다도 염두해야 한다. 입력값과 반환값에 함수형 인터페이스 타입을 활용할 수 있다. 보통은 `java.util.function` 패키지에 이미 정의된 표준 함수형 인터페이스를 사용하는 것이 가장 좋은 선택이다. 단, 흔치는 않지만 직접 새로운 함수형 인터페이스를 만들어 쓰는 편이 나을 수도 있다.

`java.util.function` 패키지에는 자바 8에서 추가된 함수형 인터페이스가 정의되어 있다. 필요한 용도에 맞는 게 있다면, 직접 구현하지 말고 표준 함수형 인터페이스를 활용하는 것이 좋다.

필요한 경우 직접 찾아보면 될 것 같다.

표준 함수형 인터페이스 (`Function<T, R>` 등)는 기본적으로 객체 타입을 다룬다. 기본 타입(int, double 등)을 사용하려면 박싱/언박싱이 발생하여 성능이 저하된다.

아래의 예시로 성능 차이를 확인해보자.

```java
public static void main(String[] args) {
    Function<Integer, Integer> square = x -> x * x; // 박싱 발생 (int -> Integer)

    long startTime = System.nanoTime();
    int sum = 0;
    for (int i = 0; i < 10_000_000; i++) {
        sum += square.apply(i); // 박싱된 Integer 사용
    }
    long endTime = System.nanoTime();

    System.out.println("박싱된 Function<Integer, Integer> 실행 시간: " + (endTime - startTime) / 1_000_000 + "ms");

    IntUnaryOperator square2 = x -> x * x; // 기본 타입 사용 (int -> int)

    long startTime2 = System.nanoTime();
    int sum2 = 0;
    for (int i = 0; i < 10_000_000; i++) {
        sum2 += square2.applyAsInt(i); // 박싱 없음
    }
    long endTime2 = System.nanoTime();

    System.out.println("기본 타입 IntUnaryOperator 실행 시간: " + (endTime2 - startTime2) / 1_000_000 + "ms");
}
```

![alt text](image.png)

자바는 이를 방지하기 위해 `IntFunction`, `IntUnaryOperator` 같은 기본 타입 전용 인터페이스를 제공한다. 기본 타입을 다룰 때는 가능하면 기본 타입 전용 함수형 인터페이스를 사용하자.

`@FunctionalInterface` 애너테이션을 사용해 함수형 인터페이스임을 명시하는 것이 좋다. 이 애너테이션을 사용하면 컴파일러가 올바르게 함수형 인터페이스를 정의했는지 확인해준다. 누군가 만들어둔 함수형 인터페이스에 메서드를 추가하려는 경우 컴파일러가 에러를 발생시켜준다. 그러니 항상 `@FunctionalInterface` 애너테이션을 사용하자.

## 아이템 45. 스트림은 주의해서 사용하라

> ### 핵심 정리
>
> 스트림과 반복 중 어느 쪽이 나은지 확신하기 어렵다면 둘 다 해보고 더 나은 쪽을 선택하자. 항상 들어맞는 규칙은 없다. 스트림이 더 나은 경우가 많지만, 반복을 사용하는 것이 더 직관적일 때도 있다. 성능 차이가 크지 않다면 더 직관적인 코드를 선택하자.

스트림 API는 다량의 데이터 처리 작업(순차적이든 병력적이든)을 지원하기 위해 자바 8에 추가되었다.

스트림 API가 제공하는 추상 개념 중 핵심은 두 가지다.

- 스트림은 데이터 원소의 유한 혹은 무한 시퀀스를 나타낸다.
- 스트림 파이프라인은 이 원소들로 수행하는 연산 단계를 표현한다.

스트림 파이프라인은 세 부분으로 구성된다.

1. 데이터 원소의 소스
2. 0개 이상의 중간 연산
3. 1개의 최종 연산

스트림 파이프라인은 지연 평가(lazy evaluation)된다. 즉, 최종 연산이 호출되기 전까지는 중간 연산이 수행되지 않는다. 이는 파이프라인을 구성하는 연산들이 가능한 한 늦게 이루어지게 하여 효율적으로 실행할 수 있게 해준다.

> 스트림은 한 번 사용하면 닫혀서 재사용이 불가능하다. 따라서 같은 데이터 원소 스트림 파이프라인을 다시 만들어야 한다. 따라서 스트림을 열었다면 변수에 할당해두고 나중에 사용하는 것처럼 미루지 말고 즉시 사용하자.

스트림에 내부 구조를 쉽게 알고 싶다면 [우아한테크코스 7기 BE 모코의 포스팅](https://velog.io/@songsunkook/Java-Stream-API-feat.-%EC%B5%9C%EC%A0%81%ED%99%94)을 참고하면 쉽게 이해할 수 있다.

핵심은 간단한 것 같다.

스트림을 과하게 사용하면, 개발자가 코드를 이해하기 힘들어지고 유지보수하기 어려워진다. 따라서 스트림과 반복 중 어느 쪽이 나은지 확신하기 어렵다면 둘 다 해보고 더 나은 쪽을 선택하자. 항상 들어맞는 규칙은 없다. 스트림이 더 나은 경우가 많지만, 반복을 사용하는 것이 더 직관적일 때도 있다. 성능 차이가 크지 않다면 더 직관적인 코드를 선택하자.

아래의 일들을 해야 한다면, 대부분 스트림이 안성맞춤이다.

- 원소들의 시퀀스를 일관되게 변환(매핑)한다.
- 원소들의 시퀀스를 필터링한다.
- 원소들의 시퀀스를 하나의 결과로 합친다.
- 원소들의 시퀀스를 그룹화한다.
- 원소들의 시퀀스에서 특정 조건을 만족하는 원소를 찾는다.

한편 스트림으로 처리하기 어려운 일도 있다. 예를 들어, 한 데이터가 파이프라인의 여러 단계를 통과할 때 이 데이터의 각 단계에서의 값들에 동시에 접근하거나, 스트림 파이프라인의 연산이 서로 상호작용해야 하는 경우이다. 이런 경우에는 반복이 더 나은 선택인 경우가 많다.

## 아이템 46. 스트림에서는 부작용 없는 함수를 사용하라

> ### 핵심 정리
>
> 스트림 파이프라인 프로그래밍의 핵심은 부작용 없는 함수 객체에 있다. 스트름 관련 객체에 건네지는 모든 함수 객체가 부작용이 없어야 한다. 종단 연산 중 forEach는 스트림이 수행한 계산 결과를 보고할 때만 사용해야 한다. 계산 자체에는 사용하지 말자. 마지막으로 toList, toSet, toMap, groupingBy, joining 같은 종단 연산은 잘 알아두자.

스트림은 함수형 프로그래밍에 기반을 두고 있다. 스트림 파이프라인은 순수 함수(pure function)를 사용해 구현하는 것이 좋다. 순수 함수란 함수의 실행이 외부 상태에 영향을 미치지 않고, 함수가 받는 인수만을 결과에 영향을 미치는 함수를 말한다. 다른 가변 상태를 참조하지 않고, 함수 스스로도 다른 상태를 변경하지 않는다. 이렇게 하려면 스트림 연산에 전달하는 함수 객체는 모두 side effect가 없어야 한다.

```java
// 스트림 패러다임을 이해하지 못한 채 API만 사용한 사례 - 따라 하지 말 것
Map<String, Long> freq = new HashMap<>();
try (Stream<String> words = new Scanner(file).tokens()) {
    words.forEach(word -> {
        freq.merge(word.toLowerCase(), 1L, Long::sum);
    });
}
```

위 코드는 스트림을 사용한 예시이다. 그러나 `forEach` 메서드는 스트림이 수행한 계산 결과를 보고할 때만 사용해야 한다. 계산 자체에는 사용하지 말아야 한다. 위 코드는 스트림을 사용한 것이지만, 스트림 패러다임을 이해하지 못한 채 API만 사용한 사례이다. 이런 경우에는 스트림을 사용하지 않는 편이 낫다.

```java
// 스트림을 제대로 활용해 최빈 단어를 구하는 파이프라인
Map<String, Long> freq;
try (Stream<String> words = new Scanner(file).tokens()) {
    freq = words.collect(groupingBy(String::toLowerCase, counting()));
}
```

위 코드는 스트림을 제대로 활용해 최빈 단어를 구하는 파이프라인이다. `groupingBy` 메서드는 스트림의 원소들을 그룹화하고, `counting` 메서드는 그룹의 원소 개수를 센다. 이렇게 하면 스트림의 원소를 처리하는 동안 외부 상태를 변경하지 않고, 스트림의 원소들만을 이용해 결과를 계산한다.

forEach 연산은 스트림이 수행한 계산 결과를 보고할 때만 사용해야 한다. 계산 자체에는 사용하지 말자.

마지막으로 stream.Collectors 클래스에 정의된 다양한 종단 연산을 잘 알아두자. toList, toSet, toMap, groupingBy, joining 등이 있다.

## 아이템 47. 반환 타입으로는 스트림보다 컬렉션이 낫다

> ### 핵심 정리
>
> 원소 시퀀스를 반환하는 메서드를 작성할 때는, 이를 스트림으로 처리하기를 원하는 사용자와 반복으로 처리하길 원하는 사용자가 모두 있을 수 있음을 고려하고, 양쪽 다 만족시키려고 노력하자. 가능하다면 컬렉션을 반환하는 것이 좋다. 다만, 컬렉션을 반환하는 메서드를 작성할 때는 반환된 컬렉션의 크기가 메모리 한계를 초과하지 않도록 주의하자.

자바 7까지는 원소 시퀀스를 반환하는 메서드의 반환 타입으로 `Collection`, `Set`, `List` 같은 컬렉션 인터페이스나 `Iterable` 인터페이스, 혹은 `배열`을 사용헸디거 힌디. 대부분의 경우 컬렉션 인터페이스를 사용했고, 일부 Collection 메서드를 구현할 수 없는 경우에는 Iterable을 사용했으며, 성능이 중요한 상황에서는 배열을 사용했었다.

그러나 자바 8에서 스트림(Stream)이 도입되면서 선택하기 더 어려워졌다. 스트림은 반복(iteration)을 직접 지원하지 않기 때문에, 스트림과 반복을 적절히 조합해야 좋은 코드가 나온다.

API가 스트림만 반환하도록 설계한다면, 반복을 원하는 사용자는 스트림을 컬렉션이나 배열로 변환해야 한다.

```java
// 스트림을 컬렉션으로 변환
List<String> list = stream.collect(Collectors.toList());

// 스트림을 배열로 변환
String[] array = stream.toArray(String[]::new);
```

반대로 API가 컬렉션만 반환한다면, 스트림을 원하는 사용자는 컬렉션에서 스트림을 생성해야 한다.

```java
// 컬렉션에서 스트림 얻기
Stream<String> stream = collection.stream();
```

이런 변환 과정은 번거로울 뿐만 아니라, 성능 저하가 발생할 수 있다.

다행히도 Collection 인터페이스는 Iterable의 하위 타입이면서 stream() 메서드도 제공하므로 반복과 스트림을 동시에 지원한다. 즉, 원소 시퀀스를 반환하는 공개 API의 반환 타입으로는 Collection이나 그 하위 타입을 사용하는 것이 일반적으로 가장 좋은 방법이다.

배열을 반환하는 경우에도 Arrays.asList나 List.of 같은 팩터리 메서드를 사용해 컬렉션으로 쉽게 변환할 수 있으므로, Collection을 반환하는 것과 큰 차이가 없다고 한다.

```java
// 배열을 컬렉션으로 변환
List<String> list = Arrays.asList(array);
// 또는 자바 9 이상에서는 List.of
List<String> listOf = List.of(array);
```

단지 컬렉션을 반환한다는 이유로 메모리 용량을 초과하는 큰 시퀀스를 메모리에 올리지 않도록 주의해야 한다. 시퀀스가 매우 크거나 무한한 경우에는 특별한 컬렉션을 구현하거나 Iterable을 반환하는 것이 적절할 수 있다.

쉽게 정리하자면, 웬만하면 컬렉션을 반환하는 것이 좋지만, 반환된 컬렉션의 크기가 메모리 한계를 초과하지 않도록 주의하는 것이 좋을 것 같다.

## 아이템 48. 스트림 병렬화는 주의해서 적용하라

> ### 핵심 정리
>
> 기대하는 것처럼 동작하고 성능도 빨라진다는 확신 없이는 스트림 파이프라인 병렬화는 시도조차 하지 말자. 스트림을 잘못 병렬화하면 프로그램이 오동작하거나 성능을 급격히 떨어뜨릴 수 있다. (심지어는 결과가 나오지 않을 수도 있다.) 확신이 들더라도 운영 환경이나 그와 유사한 환경에서 테스트해보고 성능을 측정하자.

동시성 프로그래밍 측면에서 자바는 항상 앞서갔다. 처음 릴리스된 1996년부터 스레드, 동기화, wait/notify를 지원했다. 자바 5부터는 `java.util.concurrent` 패키지를 통해 고수준 동시성 API를 제공했다. 자바 7부터는 `Fork Join Framework`를 통해 병렬 처리를 지원했다. 자바 8에서는 스트림 API를 통해 병렬 처리를 더 쉽게 만들었다.

자바로 동시성 프로그램을 작성하는 것은 쉬워졌지만, 안전한 상태를 유지하기 위해서는 여전히 많은 주의가 필요하다.

환경이 아무리 좋더라도 데이터 소스가 `Stream.iterate`나 중간 연산에서 `limit`를 사용하면 파이프라인 병렬화로는 성능 개선을 기대할 수 없다.

간단하게 설명하면 스트림 파이프라인을 무자비하게 병렬화하면 오히려 성능이 나빠질 확률이 매우 높다.

대체로 스트림의 소스가 `ArrayList`, `HashMap`, `HashSet`, `ConcurrentHashMap`의 인스턴스, 배열, int 범위, long 범위일 때 병렬화의 효과가 가장 좋다. 이런 소스를 사용할 때는 병렬화를 고려해도 좋다. 그 이유는 모두 데이터를 원하는 크기로 나누고 각 부분을 병렬로 처리할 수 있기 때문이다. (분할 정복 알고리즘과 비슷하다.)

병렬화한 파이프라인이 사용하는 mappers, filters, 혹은 프로그래머가 제공한 다른 함수 객체가 명세대로 동작하지 않을 때 벌어질 수 있는 문제를 안전 실패(safe failure, 결과가 잘못되거나 오동작하는 것)라고 한다. Stream 명세에는 이때 사용되는 함수 객체에 관한 엄중한 규약을 정의해뒀다. 꼭 읽어보자.

지금까지 병렬화를 사용하지 말라고 했지만, 조건이 잘 갖춰지면 parallel 메서드 호출 하나로 거의 프로세서 코어 수에 비례하는 성능 향상을 만끽할 수 있다고 한다.
